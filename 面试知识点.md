## 分布式一致性
- [分布式一致性](https://github.com/baidu/braft/blob/master/docs/cn/overview.md)
- [复制](https://github.com/baidu/braft/blob/master/docs/cn/replication.md)
- 2PC
- 3PC
- 单主协议(raft、paxos、zab)
- 多主协议(gossip)
- NWR协议

### 2PC 分布式事务
#### AT
#### TCC
#### SAGA
#### XA

### 单主协议
#### Raft 协议
- [RAFT介绍](https://github.com/baidu/braft/blob/master/docs/cn/raft_protocol.md)
- [RAFT算法图解](http://thesecretlivesofdata.com/raft/)
- [SOFAJRaft 介绍](https://www.sofastack.tech/projects/sofa-jraft/overview/)
- [分布式一致性 Raft 与 JRaft](https://www.sofastack.tech/projects/sofa-jraft/consistency-raft-jraft/)

#### Paxos 协议
- [Paxos简介](https://github.com/baidu/braft/blob/master/docs/cn/paxos_protocol.md)

#### Zab 协议
- [ZAB协议](https://github.com/baidu/braft/blob/master/docs/cn/zab_protocol.md)

### 多主协议
#### gossip 协议
- [P2P 网络核心技术：Gossip 协议](https://zhuanlan.zhihu.com/p/41228196)
##### Gossip 的特点（优势）
- 扩展性

    网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。

- 容错

    网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。

- 去中心化

    Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。

- 一致性收敛

    Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。

- 简单

    Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。

##### Gossip 的缺陷

分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：

- 消息的延迟

    由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。

- 消息冗余

    Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。



## 分布式解决方案
### [seata](https://seata.io/zh-cn/docs/overview/what-is-seata.html)
- [Seata AT 模式](https://seata.io/zh-cn/docs/dev/mode/at-mode.html)
- [Seata TCC 模式](https://seata.io/zh-cn/docs/dev/mode/tcc-mode.html)
- [SEATA Saga 模式](https://seata.io/zh-cn/docs/user/saga.html)
- [Seata XA 模式](https://seata.io/zh-cn/docs/dev/mode/xa-mode.html)


## 熔断限流降级

### Sentinel
- [Sentinel 介绍](https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D)
- [Sentinel 核心类解析](https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90)
- [Sentinel 集群流控](https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7)
- [Sentinel 相关文档](https://github.com/sentinel-group/sentinel-awesome)
- [Sentinel 教程](https://gitee.com/all_4_you/sentinel-tutorial)

## 缓存
### Redis
- 敖丙 《吊打面试官》系列
  - [《吊打面试官》系列-Redis基础](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453140867&idx=2&sn=5c573be40ff3e897bed2ede542ef8c34&chksm=8cf2d700bb855e166f6c8db7d89185b26139ace92ef70484084ce2abd9a6c9e66eb0f84b9695&scene=21#wechat_redirect)
  - [《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453140899&idx=3&sn=1e2dd22fdd89ae96e7ccb52a98f2a1fd&chksm=8cf2d720bb855e3664d3ad434726c99a848b6565550f7e74bdec80287df0eb624dda8eb2a6a9&scene=21#wechat_redirect)
### 缓存一致性问题怎么解决？
#### 先删缓存，再更新数据库
先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，缓存不一致发生。

##### 延时双删
延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再sleep一段时间，然后再次删除缓存。

sleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。

流程如下：
- 线程1删除缓存，然后去更新数据库
- 线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存
- 线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除
- 如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值

#### 先更新数据库，再删除缓存
如果反过来操作，先更新数据库，再删除缓存呢？

这个就更明显的问题了，更新数据库成功，如果删除缓存失败或者还没有来得及删除，那么，其他线程从缓存中读取到的就是旧值，还是会发生不一致。

##### 消息队列
这是网上很多文章里都有写过的方案。但是这个方案的缺陷会更明显一点。

先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。

这个解决方案其实问题更多。

- 引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦
- 就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的

##### 进阶版消息队列
为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。

其实，一般大公司本身都会有监听binlog消息的消息队列存在，主要是为了做一些核对的工作。

这样，我们可以借助监听binlog的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。

当然，这样消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。

而且，如果并发不是特别高的话，这种做法的实时性和一致性都还算可以接受的。

#### 其他解决方案
##### 设置缓存过期时间
每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。

如果对于一致性要求不是很高的情况，可以采用这种方案。

这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。

在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。

因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。

#### 为什么是删除，而不是更新缓存？
我们以先更新数据库，再删除缓存来举例。

如果是更新的话，那就是先更新数据库，再更新缓存。

举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？

反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库加载。

## 其他
- [零拷贝](https://mp.weixin.qq.com/s/FgBCop2zFfcX5ZszE0NoCQ)

## JVM
### 类加载过程
```
Loading(加载) --> Linking(链接)[Verification(验证) --> Preparation(准备) --> Resolution(解析)] --> Initialization(初始化)
```
#### Loading(加载)
- 通过一个类的全限定名获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- **`在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口`**
- 补充: 加载 .class 文件的方式
  - 从本地系统中直接加载
  - 通过网络获取，典型场景：Web Applet
  - 从 zip 压缩包中读取，成为日后 jar 、 war 格式的基础
  - 运行时计算生成， 使用最多的是: 动态代理技术
  - 有其他文件生成，典型场景: JSP应用
  - 从专有数据库中提取.class文件，比较少见
  - 从加密文件中获取，典型的防Class文件被反编译的保护措施 

#### Linking(链接)
##### Verify(验证)

##### Prepare(准备)

##### Resolve(解析)